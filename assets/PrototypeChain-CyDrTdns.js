import{j as e}from"./index-COrpvOC4.js";import{S as t,O as o}from"./index-BMvjhO8Z.js";import{B as s}from"./Breadcrumbs-DQDVi04u.js";function i(){return e.jsxs(t.Wrapper,{children:[e.jsx(s,{sectionLabel:"Objects & Prototypes",sectionPath:"/objects-prototypes",topics:o}),e.jsx(t.Heading,{children:"Prototype chain"}),e.jsxs(t.Prose,{children:[e.jsxs("p",{children:[e.jsx("b",{children:"Definition."})," Every object has an internal ",e.jsx("code",{children:"[[Prototype]]"})," link to another object (or ",e.jsx("code",{children:"null"}),"). Property reads walk this ",e.jsx("b",{children:"prototype chain"})," upward until found or the end (",e.jsx("code",{children:"null"}),"). Methods live on prototypes; instances delegate to them."]}),e.jsx("h2",{children:"Reading & setting the prototype"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"Object.getPrototypeOf(obj)"})," → current prototype (or ",e.jsx("code",{children:"null"}),")."]}),e.jsxs("li",{children:[e.jsx("code",{children:"Object.setPrototypeOf(obj, proto)"})," → changes it (avoid in hot paths; deopts)."]}),e.jsxs("li",{children:["Legacy ",e.jsx("code",{children:"__proto__"})," getter/setter lives on ",e.jsx("code",{children:"Object.prototype"}),"; prefer the APIs above."]}),e.jsxs("li",{children:["Create with a specific proto: ",e.jsx("code",{children:"Object.create(proto, descriptors?)"}),"."]})]}),e.jsx(t.Pre,{children:`const proto = { greet(){ return "hi"; } };
const o = Object.create(proto);
Object.getPrototypeOf(o) === proto; // true
o.greet();                          // "hi" (delegation)`}),e.jsx("h2",{children:"Lookup rules (read / write / delete)"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("b",{children:"Read:"})," if ",e.jsx("code",{children:"obj"})," lacks an own property, JS looks up ",e.jsx("code",{children:"[[Prototype]]"})," chain."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Write:"})," assignment creates/updates an ",e.jsx("b",{children:"own"})," property on the receiver, unless an",e.jsx("i",{children:"inherited accessor setter"})," handles it."]}),e.jsxs("li",{children:[e.jsx("b",{children:"Delete:"})," only removes an ",e.jsx("b",{children:"own"})," property; it won't affect inherited ones."]})]}),e.jsx(t.Pre,{children:`const base = { x: 1, set y(v){ this._y = v; } };
const obj  = Object.create(base);

obj.x;                 // 1 (found on base)
obj.x = 2;             // creates own 'x' (shadows base.x)
delete obj.x;          // removes own 'x'; base.x visible again (1)

obj.y = 10;            // calls inherited setter → writes obj._y = 10 (no own 'y' created)`}),e.jsx("h2",{children:"Functions, constructors & instances"}),e.jsxs("ul",{children:[e.jsxs("li",{children:["A function used as a constructor has a ",e.jsx("code",{children:".prototype"})," object. Instances created with ",e.jsx("code",{children:"new C()"})," have ",e.jsx("code",{children:"[[Prototype]] === C.prototype"}),"."]}),e.jsxs("li",{children:["Methods you want shared by all instances should live on ",e.jsx("code",{children:"C.prototype"}),"."]})]}),e.jsx(t.Pre,{children:`function Counter(){ this.n = 0; }
Counter.prototype.inc = function(){ this.n++; };

const c = new Counter();
c.inc(); // uses method from Counter.prototype`}),e.jsx("h2",{children:"Class syntax (sugar over prototypes)"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"class"})," puts instance methods on ",e.jsx("code",{children:"C.prototype"}),"; ",e.jsx("code",{children:"static"})," methods on the constructor ",e.jsx("code",{children:"C"}),"."]}),e.jsxs("li",{children:[e.jsx("code",{children:"extends"})," wires both chains: instances delegate to ",e.jsx("code",{children:"Child.prototype"})," → ",e.jsx("code",{children:"Parent.prototype"}),"; and the constructor chain ",e.jsx("code",{children:"Child.__proto__ === Parent"}),"."]})]}),e.jsx(t.Pre,{children:`class A { ping(){ return "A"; } static s(){ return "As"; } }
class B extends A { pong(){ return "B"; } }

const b = new B();
b.ping();  // from A.prototype
b.pong();  // from B.prototype
B.s();     // from A via constructor chain (B.__proto__ === A)`}),e.jsx("h2",{children:"Chains for built-ins (typical)"}),e.jsx(t.Pre,{children:`const arr = [];
Object.getPrototypeOf(arr) === Array.prototype;        // true
Object.getPrototypeOf(Array.prototype) === Object.prototype; // true
Object.getPrototypeOf(Object.prototype) === null;      // true`}),e.jsx("h2",{children:"Ownership & enumeration"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"Object.hasOwn(obj, k)"})," checks only own keys. ",e.jsx("code",{children:"k in obj"})," also sees prototypes."]}),e.jsxs("li",{children:[e.jsx("code",{children:"for…in"})," iterates enumerable string keys including inherited; avoid on arrays/for data transforms."]}),e.jsxs("li",{children:[e.jsx("code",{children:"Object.keys/values/entries"})," list own enumerable keys only."]})]}),e.jsx(t.Pre,{children:`const p = { a:1 }; const o = Object.create(p); o.b = 2;
Object.hasOwn(o, "a");  // false
"a" in o;               // true (inherited)
Object.keys(o);         // ["b"]`}),e.jsx("h2",{children:"Null-prototype objects (dictionary mode)"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"Object.create(null)"})," makes an object with no prototype — no accidental collisions with",e.jsx("code",{children:"toString"}),", etc."]}),e.jsxs("li",{children:["Use when you need a pure key→value map (or just use ",e.jsx("code",{children:"Map"}),")."]})]}),e.jsx(t.Pre,{children:`const dict = Object.create(null);
dict["__proto__"]; // undefined (safe)
Object.getPrototypeOf(dict) === null; // true`}),e.jsx("h2",{children:"Performance & safety notes"}),e.jsxs("ul",{children:[e.jsxs("li",{children:["Changing prototypes at runtime (",e.jsx("code",{children:"Object.setPrototypeOf"})," / ",e.jsx("code",{children:"__proto__"}),") can deopt; prefer creating with the right proto up front."]}),e.jsx("li",{children:"Composition often beats inheritance: attach needed functions directly instead of deep chains."}),e.jsxs("li",{children:["Don't confuse ",e.jsx("code",{children:"this"})," binding with prototypes: ",e.jsx("code",{children:"this"})," depends on the call-site, while method lookup uses the prototype chain."]})]}),e.jsx("h2",{children:"Quick mental model"}),e.jsx(t.Pre,{children:`// read: obj.k ?
// 1) own? return it
// 2) else walk [[Prototype]]: proto.k ? return
// 3) keep walking until null → undefined`}),e.jsx("h2",{children:"Must-know (checklist)"}),e.jsxs("ul",{children:[e.jsxs("li",{children:["Instances delegate to ",e.jsx("code",{children:"Constructor.prototype"}),"; classes are syntactic sugar over this."]}),e.jsxs("li",{children:["Reads walk the chain; writes create/modify ",e.jsx("b",{children:"own"})," props unless an inherited setter handles it."]}),e.jsxs("li",{children:["Use ",e.jsx("code",{children:"Object.create"})," to set prototypes; avoid ",e.jsx("code",{children:"setPrototypeOf"})," in hot paths."]}),e.jsxs("li",{children:["Use ",e.jsx("code",{children:"Object.hasOwn"})," vs ",e.jsx("code",{children:"in"})," depending on whether prototypes should count."]}),e.jsxs("li",{children:["Null-prototype objects for dictionaries; consider ",e.jsx("code",{children:"Map"})," for richer key types."]})]})]})]})}export{i as default};
